\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Z\"uchtungslehre - L\"osung 6}
\author{Peter von Rohr}
\maketitle

<<HelperFunctions, echo=FALSE, results=hide>>=
#' Function returning a matrix as tex output
#' @param  pmatAMatrix        Matrix to be represented in tex format
#' @param  pnOutStartLine     line index where output should start, default = 5
#' @param  pnEndIgnoreLines   number of lines to be ignored at the end of the output, default = 1
#' @return string containing tex representation of matrix
sGetTexMatrix <- function(pmatAMatrix, pnOutStartLine = 5, pnEndIgnoreLines = 1) {
  sResultTexMatrix <- capture.output(print(xtable::xtable(pmatAMatrix),
                                     include.rownames = FALSE,
                                     include.colnames = FALSE,
                                     hline.after = NULL,
                                     sanitize.text.function=identity))
  ### # do some replacements
  sResultTexMatrix <- gsub("tabular", "array",
                           sResultTexMatrix[pnOutStartLine:(length(sResultTexMatrix)-pnEndIgnoreLines)],
                           fixed = TRUE)
  return(sResultTexMatrix)
}

#' Parse and evaluate a matrix of strings
#'
#' \code{matParseEval} takes a matrix of strings and parses and evaluates the components
#'
mParseEval <- function(pmStringMat) {
  nRowResultMat <- nrow(pmStringMat)
  nColResultMat  <- ncol(pmStringMat)
  mResultMat <- matrix(0, nrow = nRowResultMat, ncol = nColResultMat)
  for (idx in 1:nRowResultMat){
    for (jdx in 1:nColResultMat) {
      mResultMat[idx,jdx] <- eval(parse(text=pmStringMat[idx,jdx]))
    }
  }
  return(mResultMat)
}

#' Add a string to a component of a character matrix
#'
#' @param pmMat         input character matrix
#' @param psPasteToComp   string to be added to matrix component
#' @param pnRowIdx      row index of matrix component where string should be added
#' @param pnColIdx      column index of matrix component where string should be added
#' @return mResultMat   result matrix after adding string to component
matPasteStringToMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  mResultMat <- pmMat
  mResultMat[pnRowIdx, pnColIdx] <- paste(mResultMat[pnRowIdx, pnColIdx], psPasteToComp, sep = "")
  return(mResultMat)
}

matAddStringToMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  sPlusSign <- "+"
  sPlusComp <- paste(sPlusSign, psPasteToComp, sep = "")
  return(matPasteStringToMatrixComp(pmMat = pmMat,
                                    psPasteToComp = sPlusComp,
                                    pnRowIdx = pnRowIdx,
                                    pnColIdx = pnColIdx))
}

matSubStringFromMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  sMinusSign <- "-"
  sMinusComp <- paste(sMinusSign, psPasteToComp, sep = "")
  return(matPasteStringToMatrixComp(pmMat = pmMat,
                                    psPasteToComp = sMinusComp,
                                    pnRowIdx = pnRowIdx,
                                    pnColIdx = pnColIdx))
}
@


\section*{Aufgabe 1 (5)}
F\"ur Aufgabe 1 wurde folgendes Pedigree verwendet

<<pedA1>>=
library(pedigreemm)
nAnzTiere <- 6
pedA1 <- pedigree(sire = c(NA,NA,1, 1,4,4),
                dam  = c(NA,NA,2,NA,2,2), label= 1:nAnzTiere)
print(pedA1)
@

Die $\alpha_i$-Werte f\"ur die Tiere im Pedigree sind in folgender Tabelle aufgelistet.

\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 & 1.00 \\
      \hline
   2 & 1.00 \\
      \hline
   3 & 2.00 \\
      \hline
   4 & 1.33 \\
      \hline
   5 & 2.00 \\
      \hline
   6 & 2.00 \\
   \hline
\end{tabular}
\end{center}


<<pedMM, echo=FALSE, results=hide>>=
### # Aufbau der Matrix
matAInv <- matrix("0", nrow = nAnzTiere, ncol = nAnzTiere)
alpha <- 1/Dmat(pedA1)
nTierIdx <- 1
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 2
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 3
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nVaterIdx <- 1
nMutterIdx <- 2
matAInv[nVaterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nVaterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nMutterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nMutterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nVaterIdx,nVaterIdx] <- paste(matAInv[nVaterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nVaterIdx,nMutterIdx] <- paste(matAInv[nVaterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nVaterIdx] <- paste(matAInv[nMutterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nMutterIdx] <- paste(matAInv[nMutterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
mParsedEvaledAinv <- mParseEval(pmStringMat = matAInv)
@

Das direkte Aufstellen der inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$ basiert auf folgenden Regeln.

\subsection*{Regeln f\"ur $\mathbf{A}^{-1}$}

\begin{itemize}
\item Initialisierung aller Elemente in $\mathbf{A}^{-1}$ mit dem Wert $0$
\item Hat Tier $i$ bekannte Eltern $m$ und $v$ dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$ (Zeile von Tier $i$ und Kolonne von Tier $i$) hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$, $(i,m)$, $(v,i)$ und $(i,v)$ abziehen
  \item ${\alpha_i \over 4}$ zu den Elementen $(m,m)$, $(m,v)$, $(v,m)$ und $(v,v)$ hinzuz\"ahlen
  \end{itemize}
\item Nur Elternteil $m$ von Tier $i$ ist bekannt, dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$ und $(i,m)$ abziehen
  \item ${\alpha_i \over 4}$ zum Element $(m,m)$ hinzuz\"ahlen
  \end{itemize}
\item Tier $i$ hat keine bekannten Eltern, dann $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
\end{itemize}

\subsection*{Schritte 1 bis 3}
Schritte 1 bis 3 zur Berechnung der Anteile von $\mathbf{A}^{-1}$ f\"ur Tiere 1 bis 3 wurden in der Aufgabe vorgegeben. Nach diesen drei Schritten sieht die Matrix $\mathbf{A}^{-1}$ wie folgt aus

<<MatAInvStepThree, echo=FALSE, results=tex>>=
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Schritt 4}
Tier 4 hat nur einen bekannten Elternteil. Aus der Tabelle der $\alpha_i$ Werte kann $\alpha_4 = 1.33$ bestimmt werden.  Somit werden folgende Betr\"age zu $\mathbf{A}^{-1}$ hinzugef\"ugt.

<<ContribStep4, echo=FALSE, results=hide>>=
nTierIdx <- 4
nVaterIdx <- pedA1@sire[nTierIdx]
nRoundAlpha4 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha4Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha4Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha4}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha4Half}$
  von den Elementen $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$ und
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$ abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha4Quater}$
  zum Element $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$ hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 4 wie folgt aus.

<<MatAInvAfter4, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 1
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Schritte 5 und 6}
Tiere 5 und 6 haben bekannte Eltern 4 und 2, somit werden folgende Beitr\"age zu $\mathbf{A}^{-1}$ hinzugef\"ugt.

\noindent F\"ur Tier 5
<<ContribStep5, echo=FALSE, results=hide>>=
nTierIdx <- 5
nVaterIdx <- pedA1@sire[nTierIdx]
nMutterIdx <- pedA1@dam[nTierIdx]
nRoundAlpha5 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha5Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha5Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha5}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha5Half}$
  von den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$,
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nTierIdx})$  und
  $(\Sexpr{nTierIdx},\Sexpr{nMutterIdx})$
  abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha5Quater}$
  zu den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nMutterIdx})$,
  $(\Sexpr{nVaterIdx},\Sexpr{nMutterIdx})$ und
  $(\Sexpr{nMutterIdx},\Sexpr{nVaterIdx})$
  hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 5 wie folgt aus.

<<MatAInvAfter5, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 4
nMutterIdx <- 2
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\noindent F\"ur Tier 6

<<ContribStep6, echo=FALSE, results=hide>>=
nTierIdx <- 6
nVaterIdx <- pedA1@sire[nTierIdx]
nMutterIdx <- pedA1@dam[nTierIdx]
nRoundAlpha6 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha6Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha6Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha6}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha6Half}$
  von den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$,
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nTierIdx})$  und
  $(\Sexpr{nTierIdx},\Sexpr{nMutterIdx})$
  abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha6Quater}$
  zu den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nMutterIdx})$,
  $(\Sexpr{nVaterIdx},\Sexpr{nMutterIdx})$ und
  $(\Sexpr{nMutterIdx},\Sexpr{nVaterIdx})$
  hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 6 wie folgt aus.

<<MatAInvAfter5, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 4
nMutterIdx <- 2
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\noindent Nach Vereinfachung der Summen haben wir folgend Matrix als Resultat

<<MatAInvA1Result, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- mParseEval(pmStringMat = mParsedEvaledAinv)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Kontrolle}
Als Kontrolle rechnen wir die Inverse Verwandtschaftsmatrix mit der Funktion \texttt{getAInv()}

<<CheckGetAInv>>=
(matCheckAInv <- round(as.matrix(getAInv(pedA1)), digits = 2))
max(mParsedEvaledAinv-matCheckAInv)
@

\section*{Aufgabe 2 (7)}
F\"ur Aufgabe 2 arbeiten wir mit einem im Vergleich zu Aufgabe 1 leicht modifizierten Pedigree.

<<PedA2>>=
library(pedigreemm)
nAnzTiere <- 6
pedA2 <- pedigree(sire = c(NA,NA,1, 1,4,5),
                dam  = c(NA,NA,2,NA,3,2), label= 1:nAnzTiere)
print(pedA2)
@

\noindent In der Aufgabenstellung wurden die $\alpha_i$ Werte f\"ur die ersten drei Tiere bereits vorgegeben.

\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 &  1\\
      \hline
   2 &  1\\
      \hline
   3 &  2\\
      \hline
   4 &  \\
      \hline
   5 &  \\
      \hline
   6 &  \\
   \hline
\end{tabular}
\end{center}

\subsection*{Berechnung der $\alpha_i$}
Die $\alpha_i$ Werte entsprechen den Diagonalelementen der Matrix $\mathbf{D}^{-1}$ aus der LDL-Zerlegung der inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$. Da die Matrix $\mathbf{D}^{-1}$ und somit auch die Matrix $\mathbf{D}$ beides Diagonalmatrizen sind, lassen sich die $\alpha_i$ Werte einfach aus den Diagonalelementen $d_{i}$ der Matrix $\mathbf{D}$ berechnen. Aufgrund der Eigenschaften einer Diagonalmatrix gilt, dass

\begin{equation}
\alpha_i = {1 \over d_i}
\end{equation}

Aus der LDL-Zerlegung und der Cholesky-Zerlegung der Verwandtschaftsmatrix $\mathbf{A}$ k\"onnen wir die $d_i$ Werte berechnen

\begin{equation}
\mathbf{A} = \mathbf{L}*\mathbf{D}*\mathbf{L}^{T} = \mathbf{U}*\mathbf{U}^{T}
\end{equation}

\noindent Aus den zwei Zerlegungen von $\mathbf{A}$ folgt, dass

\begin{equation}
\mathbf{U} = \mathbf{L}*\mathbf{S}
\end{equation}

\noindent wobei $\mathbf{S}$ eine Diagonalmatrix ist deren Elemente $s_i = \sqrt{d_i}$ entsprechen. Da die Matrix $\mathbf{L}$ eine untere Dreiecksmatrix mit Diagonalelementen $l_i = 1$ ist, entsprechen die Diagonalelemente $u_i$ der Matrix $\mathbf{U}$ den Diagonalelementen $s_i$ der Matrix $\mathbf{S}$. Es gilt also $u_i = s_i = \sqrt{d_i}$.
\end{document}
