\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Z\"uchtungslehre - L\"osung 6}
\author{Peter von Rohr}
\maketitle

<<HelperFunctions, echo=FALSE, results=hide>>=
#' Function returning a matrix as tex output
#' @param  pmatAMatrix        Matrix to be represented in tex format
#' @param  pnOutStartLine     line index where output should start, default = 5
#' @param  pnEndIgnoreLines   number of lines to be ignored at the end of the output, default = 1
#' @return string containing tex representation of matrix
sGetTexMatrix <- function(pmatAMatrix, pnOutStartLine = 5, pnEndIgnoreLines = 1) {
  sResultTexMatrix <- capture.output(print(xtable::xtable(pmatAMatrix),
                                     include.rownames = FALSE,
                                     include.colnames = FALSE,
                                     hline.after = NULL,
                                     sanitize.text.function=identity))
  ### # do some replacements
  sResultTexMatrix <- gsub("tabular", "array",
                           sResultTexMatrix[pnOutStartLine:(length(sResultTexMatrix)-pnEndIgnoreLines)],
                           fixed = TRUE)
  return(sResultTexMatrix)
}

#' Parse and evaluate a matrix of strings
#'
#' \code{matParseEval} takes a matrix of strings and parses and evaluates the components
#'
mParseEval <- function(pmStringMat) {
  nRowResultMat <- nrow(pmStringMat)
  nColResultMat  <- ncol(pmStringMat)
  mResultMat <- matrix(0, nrow = nRowResultMat, ncol = nColResultMat)
  for (idx in 1:nRowResultMat){
    for (jdx in 1:nColResultMat) {
      mResultMat[idx,jdx] <- eval(parse(text=pmStringMat[idx,jdx]))
    }
  }
  return(mResultMat)
}

#' Add a string to a component of a character matrix
#'
#' @param pmMat         input character matrix
#' @param psPasteToComp   string to be added to matrix component
#' @param pnRowIdx      row index of matrix component where string should be added
#' @param pnColIdx      column index of matrix component where string should be added
#' @return mResultMat   result matrix after adding string to component
matPasteStringToMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  mResultMat <- pmMat
  mResultMat[pnRowIdx, pnColIdx] <- paste(mResultMat[pnRowIdx, pnColIdx], psPasteToComp, sep = "")
  return(mResultMat)
}

matAddStringToMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  sPlusSign <- "+"
  sPlusComp <- paste(sPlusSign, psPasteToComp, sep = "")
  return(matPasteStringToMatrixComp(pmMat = pmMat,
                                    psPasteToComp = sPlusComp,
                                    pnRowIdx = pnRowIdx,
                                    pnColIdx = pnColIdx))
}

matSubStringFromMatrixComp <- function(pmMat, psPasteToComp, pnRowIdx, pnColIdx) {
  sMinusSign <- "-"
  sMinusComp <- paste(sMinusSign, psPasteToComp, sep = "")
  return(matPasteStringToMatrixComp(pmMat = pmMat,
                                    psPasteToComp = sMinusComp,
                                    pnRowIdx = pnRowIdx,
                                    pnColIdx = pnColIdx))
}
@


\section*{Aufgabe 1 (5)}
F\"ur Aufgabe 1 wurde folgendes Pedigree verwendet

<<pedA1>>=
library(pedigreemm)
nAnzTiere <- 6
pedA1 <- pedigree(sire = c(NA,NA,1, 1,4,4),
                dam  = c(NA,NA,2,NA,2,2), label= 1:nAnzTiere)
print(pedA1)
@

Die $\alpha_i$-Werte f\"ur die Tiere im Pedigree sind in folgender Tabelle aufgelistet.

\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 & 1.00 \\
      \hline
   2 & 1.00 \\
      \hline
   3 & 2.00 \\
      \hline
   4 & 1.33 \\
      \hline
   5 & 2.00 \\
      \hline
   6 & 2.00 \\
   \hline
\end{tabular}
\end{center}


<<pedMM, echo=FALSE, results=hide>>=
### # Aufbau der Matrix
matAInv <- matrix("0", nrow = nAnzTiere, ncol = nAnzTiere)
alpha <- 1/Dmat(pedA1)
nTierIdx <- 1
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 2
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 3
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nVaterIdx <- 1
nMutterIdx <- 2
matAInv[nVaterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nVaterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nMutterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nMutterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nVaterIdx,nVaterIdx] <- paste(matAInv[nVaterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nVaterIdx,nMutterIdx] <- paste(matAInv[nVaterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nVaterIdx] <- paste(matAInv[nMutterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nMutterIdx] <- paste(matAInv[nMutterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
mParsedEvaledAinv <- mParseEval(pmStringMat = matAInv)
@

Das direkte Aufstellen der inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$ basiert auf folgenden Regeln.

\subsection*{Regeln f\"ur $\mathbf{A}^{-1}$}

\begin{itemize}
\item Initialisierung aller Elemente in $\mathbf{A}^{-1}$ mit dem Wert $0$
\item Hat Tier $i$ bekannte Eltern $m$ und $v$ dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$ (Zeile von Tier $i$ und Kolonne von Tier $i$) hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$, $(i,m)$, $(v,i)$ und $(i,v)$ abziehen
  \item ${\alpha_i \over 4}$ zu den Elementen $(m,m)$, $(m,v)$, $(v,m)$ und $(v,v)$ hinzuz\"ahlen
  \end{itemize}
\item Nur Elternteil $m$ von Tier $i$ ist bekannt, dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$ und $(i,m)$ abziehen
  \item ${\alpha_i \over 4}$ zum Element $(m,m)$ hinzuz\"ahlen
  \end{itemize}
\item Tier $i$ hat keine bekannten Eltern, dann $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
\end{itemize}

\subsection*{Schritte 1 bis 3}
Schritte 1 bis 3 zur Berechnung der Anteile von $\mathbf{A}^{-1}$ f\"ur Tiere 1 bis 3 wurden in der Aufgabe vorgegeben. Nach diesen drei Schritten sieht die Matrix $\mathbf{A}^{-1}$ wie folgt aus

<<MatAInvStepThree, echo=FALSE, results=tex>>=
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Schritt 4}
Tier 4 hat nur einen bekannten Elternteil. Aus der Tabelle der $\alpha_i$ Werte kann $\alpha_4 = 1.33$ bestimmt werden.  Somit werden folgende Betr\"age zu $\mathbf{A}^{-1}$ hinzugef\"ugt.

<<ContribStep4, echo=FALSE, results=hide>>=
nTierIdx <- 4
nVaterIdx <- pedA1@sire[nTierIdx]
nRoundAlpha4 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha4Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha4Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha4}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha4Half}$
  von den Elementen $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$ und
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$ abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha4Quater}$
  zum Element $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$ hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 4 wie folgt aus.

<<MatAInvAfter4, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 1
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Schritte 5 und 6}
Tiere 5 und 6 haben bekannte Eltern 4 und 2, somit werden folgende Beitr\"age zu $\mathbf{A}^{-1}$ hinzugef\"ugt.

\noindent F\"ur Tier 5
<<ContribStep5, echo=FALSE, results=hide>>=
nTierIdx <- 5
nVaterIdx <- pedA1@sire[nTierIdx]
nMutterIdx <- pedA1@dam[nTierIdx]
nRoundAlpha5 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha5Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha5Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha5}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha5Half}$
  von den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$,
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nTierIdx})$  und
  $(\Sexpr{nTierIdx},\Sexpr{nMutterIdx})$
  abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha5Quater}$
  zu den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nMutterIdx})$,
  $(\Sexpr{nVaterIdx},\Sexpr{nMutterIdx})$ und
  $(\Sexpr{nMutterIdx},\Sexpr{nVaterIdx})$
  hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 5 wie folgt aus.

<<MatAInvAfter5, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 4
nMutterIdx <- 2
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\noindent F\"ur Tier 6

<<ContribStep6, echo=FALSE, results=hide>>=
nTierIdx <- 6
nVaterIdx <- pedA1@sire[nTierIdx]
nMutterIdx <- pedA1@dam[nTierIdx]
nRoundAlpha6 <- round(alpha[nTierIdx], digits=2)
nRoundAlpha6Half <- round(alpha[nTierIdx]/2, digits=2)
nRoundAlpha6Quater <- round(alpha[nTierIdx]/4, digits=2)
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{nRoundAlpha6}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{nRoundAlpha6Half}$
  von den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$,
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nTierIdx})$  und
  $(\Sexpr{nTierIdx},\Sexpr{nMutterIdx})$
  abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{nRoundAlpha6Quater}$
  zu den Elementen
  $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$,
  $(\Sexpr{nMutterIdx},\Sexpr{nMutterIdx})$,
  $(\Sexpr{nVaterIdx},\Sexpr{nMutterIdx})$ und
  $(\Sexpr{nMutterIdx},\Sexpr{nVaterIdx})$
  hinzuz\"ahlen
\end{itemize}

\noindent Somit sieht die Matrix $\mathbf{A}^{-1}$ nach Schritt 6 wie folgt aus.

<<MatAInvAfter5, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx], digits = 2),
                                        pnRowIdx = nTierIdx,
                                        pnColIdx = nTierIdx)

nVaterIdx <- 4
nMutterIdx <- 2
mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

mParsedEvaledAinv <- matSubStringFromMatrixComp(pmMat = mParsedEvaledAinv,
                                          psPasteToComp = round(alpha[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
mParsedEvaledAinv <- matAddStringToMatrixComp(pmMat = mParsedEvaledAinv,
                                        psPasteToComp = round(alpha[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\noindent Nach Vereinfachung der Summen haben wir folgend Matrix als Resultat

<<MatAInvA1Result, echo=FALSE, results=tex>>=
mParsedEvaledAinv <- mParseEval(pmStringMat = mParsedEvaledAinv)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Kontrolle}
Als Kontrolle rechnen wir die Inverse Verwandtschaftsmatrix mit der Funktion \texttt{getAInv()}

<<CheckGetAInv>>=
(matCheckAInv <- round(as.matrix(getAInv(pedA1)), digits = 2))
max(mParsedEvaledAinv-matCheckAInv)
@

\section*{Aufgabe 2 (7)}
F\"ur Aufgabe 2 arbeiten wir mit einem im Vergleich zu Aufgabe 1 leicht modifizierten Pedigree.

<<PedA2>>=
library(pedigreemm)
nAnzTiere <- 6
pedA2 <- pedigree(sire = c(NA,NA,1, 1,4,5),
                dam  = c(NA,NA,2,NA,3,2), label= 1:nAnzTiere)
print(pedA2)
@

\noindent In der Aufgabenstellung wurden die $\alpha_i$ Werte f\"ur die ersten drei Tiere bereits vorgegeben.

\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 &  1\\
      \hline
   2 &  1\\
      \hline
   3 &  2\\
      \hline
   4 &  \\
      \hline
   5 &  \\
      \hline
   6 &  \\
   \hline
\end{tabular}
\end{center}

\subsection*{Berechnung der $\alpha_i$}
Die $\alpha_i$ Werte entsprechen den Diagonalelementen der Matrix $\mathbf{D}^{-1}$ aus der LDL-Zerlegung der inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$. Da die Matrix $\mathbf{D}^{-1}$ und somit auch die Matrix $\mathbf{D}$ beides Diagonalmatrizen sind, lassen sich die $\alpha_i$ Werte einfach aus den Diagonalelementen $d_{ii}$ der Matrix $\mathbf{D}$ berechnen. Aufgrund der Eigenschaften einer Diagonalmatrix gilt, dass

\begin{equation}
\alpha_i = {1 \over d_{ii}}
\end{equation}

Aus der LDL-Zerlegung und der Cholesky-Zerlegung der Verwandtschaftsmatrix $\mathbf{A}$ k\"onnen wir die $d_{ii}$ Werte berechnen

\begin{equation}
\mathbf{A} = \mathbf{L}*\mathbf{D}*\mathbf{L}^{T} = \mathbf{U}*\mathbf{U}^{T}
\end{equation}

\noindent Aus den zwei Zerlegungen von $\mathbf{A}$ folgt, dass

\begin{equation}
\mathbf{U} = \mathbf{L}*\mathbf{S}
\end{equation}

\noindent wobei $\mathbf{S}$ eine Diagonalmatrix ist deren Elemente $s_{ii} = \sqrt{d_{ii}}$ entsprechen. Da die Matrix $\mathbf{L}$ eine untere Dreiecksmatrix mit Diagonalelementen $l_{ii} = 1$ ist, entsprechen die Diagonalelemente $u_{ii}$ der Matrix $\mathbf{U}$ den Diagonalelementen $s_{ii}$ der Matrix $\mathbf{S}$. Es gilt also

\begin{equation}
u_{ii} = s_{ii} = \sqrt{d_{ii}} = {1 \over \sqrt{\alpha_i}}
\label{eq:DiagonalUii}
\end{equation}

\noindent Diese Beziehung in Gleichung (\ref{eq:DiagonalUii}) zeigt, dass wir $\alpha_i$ aus den $u_{ii}$ berechnen k\"onnen, wobei gilt, dass aufgrund von (\ref{eq:DiagonalUii})
$\alpha_i = {1\over u_{ii}^2}$ ist. Sobald wir also f\"ur jedes Tier $i$ das entsprechende Diagonalelement $u_{ii}$ der Matrix $\mathbf{U}$ bestimmen k\"onnen, wissen wir auch das zugeh\"orige $\alpha_i$.

In der Vorlesung hatten wir gesehen, dass die Diagonalelemente von $\mathbf{D}$ berechnet werden als

\begin{equation}
d_{ii} = 1 - 0.25(a_{ss} + a_{dd})
\label{eq:DiagonalDii}
\end{equation}

\noindent wobei $s$ und $d$ die Eltern von $i$ sind und $a_{ss}$ und $a_{dd}$ die den Eltern entsprechenden Diagonalelemente aus der Verwandtschaftsmatrix sind.

\noindent Setzen wir Gleichung (\ref{eq:DiagonalDii}) in Gleichung (\ref{eq:DiagonalUii}) ein, dann folgt

\begin{equation}
u_{ii} = s_{ii} = \sqrt{d_{ii}} = \sqrt{1 - 0.25(a_{ss} + a_{dd})}
\label{eq:DiagonalUii2}
\end{equation}

Aufgrund der Cholesky-Zerlegung von $\mathbf{A} = \mathbf{U}*\mathbf{U}^{T}$ k\"onnen die Diagonalelemente $a_{ii}$ von $\mathbf{A}$ berechnet werden als

\begin{equation}
a_{ii} = \sum_{m=1}^{i} u_{im}^2
\label{eq:DiagonalAii}
\end{equation}

\noindent Setzen wir die Beziehung aus Gleichung (\ref{eq:DiagonalAii}) in Gleichung (\ref{eq:DiagonalUii2}) dann erhalten wir eine rekursive Formel f\"ur $u_{ii}$

\begin{equation}
u_{ii} = \sqrt{1 - 0.25(a_{ss} + a_{dd})}
       = \sqrt{1 - 0.25(\sum_{m=1}^{s} u_{sm}^2 + \sum_{m=1}^{d} u_{dm}^2)}
\label{eq:DiagonalUiiRekursiv}
\end{equation}

Die Nebendiagonalelemente $u_{ij}$, wobei $i\ne j$ der Matrix $\mathbf{U}$ werden berechnet als

\begin{equation}
u_{ij} = 0.5 (u_{sj} + u_{dj})
\label{eq:OffDiagUij}
\end{equation}

\noindent wobei, $s$ und $d$ die Eltern von Tier $i$ sind.


\subsection*{Schritt 4}
Tier 4 hat Tier 1 als Vater und keine bekannte Mutter. Mit der rekursiven Formel aus Gleichung \ref{eq:DiagonalUiiRekursiv} berechnen wir $u_{44}$ als

\begin{equation}
u_{44} = \sqrt{1 - 0.25(\sum_{m=1}^{1} u_{sm}^2)} = \sqrt{1- 0.25  * u_{11}^2} = \sqrt{0.75}
\label{eq:DiagonalU44Rekursiv}
\end{equation}

\noindent und
\begin{equation}
\alpha_4 = {1\over u_{44}^2} = {1\over 0.75} = {4 \over 3} \approx 1.33
\label{eq:DiagonalAlpha4Rekursiv}
\end{equation}


\subsection*{Schritt 5}
Tier 5 hat bekannte Eltern 4 und 3. Die Formel f\"ur $u{55}$ lautet somit

\begin{eqnarray}
u_{55} & = & \sqrt{1 - 0.25(\sum_{m=1}^{4} u_{sm}^2 + \sum_{m=1}^3 u_{dm}^2)} \\
       & = & \sqrt{1- 0.25(u_{41}^2 + u_{42}^2 + u_{43}^2 + u_{44}^2 + u_{31}^2 + u_{32}^2 + u_{33}^2)}\nonumber
\label{eq:DiagonalU55Rekursiv}
\end{eqnarray}

\noindent Als Vorbereitung m\"ussen wir zuerst die Off-Diagonalelemente in Gleichung (\ref{eq:DiagonalU55Rekursiv}) berechnen.

\begin{eqnarray}
u_{41} & = & 0.5 * u_{11} = 0.5\nonumber\\
u_{42} & = & 0.5 * u_{12} = 0\nonumber\\
u_{43} & = & 0.5 * u_{13} = 0\nonumber\\
u_{44} & = & \sqrt{0.75}\nonumber
\label{eq:DiagonalU4jRekursiv}
\end{eqnarray}

\begin{eqnarray}
u_{31} & = & 0.5 * (u_{11} + u_{21}) = 0.5\nonumber\\
u_{32} & = & 0.5 * (u_{12} + u_{22}) = 0.5\nonumber\\
u_{33} & = & \sqrt{0.5}\nonumber
\label{eq:DiagonalU3jRekursiv}
\end{eqnarray}

\noindent Einsetzen der Werte f\"uhrt zu

\begin{eqnarray}
u_{55} & = & \sqrt{1- 0.25(0.25 + 0.75 + 0.25 + 0.25 + 0.5)} = \sqrt{0.5}
\label{eq:DiagonalU55Result}
\end{eqnarray}

\begin{equation}
\alpha_5 = {1\over u_{55}^2} = {1\over 0.5} = 2
\label{eq:DiagonalAlpha5Rekursiv}
\end{equation}


\subsection*{Schritt 6}
Tier 6 hat bekannte Eltern 5 und 2. Der Wert $u_{66}$ kann somit berechnet werden als

\begin{eqnarray}
u_{66} & = & \sqrt{1 - 0.25(\sum_{m=1}^{5} u_{sm}^2 + \sum_{m=1}^2 u_{dm}^2)} \\
       & = & \sqrt{1- 0.25(u_{51}^2 + u_{52}^2 + u_{53}^2 + u_{54}^2 + u_{55}^2 + u_{21}^2 + u_{22}^2)}\nonumber
\label{eq:DiagonalU66Rekursiv}
\end{eqnarray}

Die in Gleichung (\ref{eq:DiagonalU66Rekursiv}) verwendeten Offdiagonalelemente entsprechen

\begin{eqnarray}
u_{51} & = & 0.5*(u_{41} + u_{31}) = 0.5*(u_{41} + 0.5*(u_{11} + u_{21})) = 0.5 * (0.5 + 0.5*(1+0)) = 0.5\nonumber\\
u_{52} & = & 0.5*(u_{42} + u_{32}) = 0.5*(u_{42} + 0.5*(u_{12} + u_{22})) = 0.5 * (0 + 0.5*(0 + 1)) = 0.25\nonumber\\
u_{53} & = & 0.5*(u_{43} + u_{33}) = 0.5*(0 + \sqrt{0.5}) = \sqrt{0.125}\nonumber\\
u_{54} & = & 0.5*(u_{44} + u_{34}) = 0.5 *(\sqrt{0.75} + 0) = \sqrt{3/16}\nonumber \\
u_{55} & = & \sqrt{0.5}\nonumberË†
\label{eq:DiagonalU4jRekursiv}
\end{eqnarray}

\begin{eqnarray}
u_{21}  & = & 0\nonumber\\
u_{22}  & = & 1\nonumber
\label{eq:DiagonalU2jRekursiv}
\end{eqnarray}

\noindent Durch Einsetzen der Offdiagonalelemente erhalten wir

\begin{eqnarray}
u_{66} & = & \sqrt{1- 0.25(1/4 + 1/16 + 1/8 + 3/16 + 1/2 + 1)} = \sqrt{15/32} \nonumber
\label{eq:DiagonalU66Result}
\end{eqnarray}

\noindent und

\begin{equation}
\alpha_6 = {1\over u_{66}^2} = {32\over 15} \approx 2.133
\label{eq:DiagonalAlpha6Rekursiv}
\end{equation}

Zusammengefasst in der vorgegebenen Tabelle sehen die $\alpha_i$ Werte wie folgt aus


\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 &  1\\
      \hline
   2 &  1\\
      \hline
   3 &  2\\
      \hline
   4 &  $4/3$\\
      \hline
   5 &  2\\
      \hline
   6 &  $32/15$\\
   \hline
\end{tabular}
\end{center}

Als Kontrolle k\"onnen die $\alpha_i$ Werte auch mit der Funktion \texttt{Dmat()} berechnet werden.

<<AlphaPed2Kontrolle>>=
1/Dmat(pedA2)
@

\subsection*{Zusatzaufgabe}
Als Zusatzaufgabe sollen wir die inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$ mit den soeben berechneten $\alpha_i$ Werten aufstellen. Das Vorgehen ist gleich, wie unter Aufgabe 1 gezeigt, nur die $\alpha_i$ Werte sind anders. Im folgenden werden die Beitr\"age zur Matrix $\mathbf{A}^{-1}$ f\"ur jedes Tier aufgef\"uhrt

<<pedMMA2, echo=FALSE, results=hide>>=
### # Aufbau der Matrix
matAInvA2 <- matrix("0", nrow = nAnzTiere, ncol = nAnzTiere)
alphaA2 <- 1/Dmat(pedA2)
@


\subsubsection*{Beitrag aufgrund von Tier 1}
<<MatAInvA2Tier1, echo=FALSE, results=tex>>=
nTierIdx <- 1
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@


\subsubsection*{Beitrag aufgrund von Tier 2}
<<MatAInvA2Tier2, echo=FALSE, results=tex>>=
nTierIdx <- 2
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@


\subsubsection*{Beitr\"age aufgrund von Tier 3}
<<MatAInvA2Tier3, echo=FALSE, results=tex>>=
nTierIdx <- 3
nVaterIdx <- 1
nMutterIdx <- 2
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@


\subsubsection*{Beitr\"age aufgrund von Tier 4}
<<MatAInvA2Tier4, echo=FALSE, results=tex>>=
nTierIdx <- 4
nVaterIdx <- 1
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)


matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@


\subsubsection*{Beitr\"age aufgrund von Tier 5}
<<MatAInvA2Tier5, echo=FALSE, results=tex>>=
nTierIdx <- 5
nVaterIdx <- 4
nMutterIdx <- 3
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@


\subsubsection*{Beitr\"age aufgrund von Tier 6}
<<MatAInvA2Tier6, echo=FALSE, results=tex>>=
nTierIdx <- 6
nVaterIdx <- 5
nMutterIdx <- 2
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                      psPasteToComp = round(alphaA2[nTierIdx], digits = 2),
                                      pnRowIdx = nTierIdx,
                                      pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nVaterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nVaterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nTierIdx,
                                          pnColIdx = nMutterIdx)

matAInvA2 <- matSubStringFromMatrixComp(pmMat = matAInvA2,
                                          psPasteToComp = round(alphaA2[nTierIdx]/2, digits = 2),
                                          pnRowIdx = nMutterIdx,
                                          pnColIdx = nTierIdx)

matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nVaterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nVaterIdx,
                                        pnColIdx = nMutterIdx)
matAInvA2 <- matAddStringToMatrixComp(pmMat = matAInvA2,
                                        psPasteToComp = round(alphaA2[nTierIdx]/4, digits = 2),
                                        pnRowIdx = nMutterIdx,
                                        pnColIdx = nVaterIdx)

cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = matAInvA2), collapse = "\n"))
cat("\\right] $$\n")
@

\noindent Nach dem Aufl\"osen aller Summen resultiert folgende Matrix

<<AInvA2Result, echo=FALSE, results=tex>>=
mParsedEvaledAinvA2 <- mParseEval(pmStringMat = matAInvA2)
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinvA2), collapse = "\n"))
cat("\\right] $$\n")
@

\clearpage
\pagebreak

\noindent Zur Kontrolle vergleichen wir unser Resultat mit dem Resultat der Funktion \texttt{getAInv()}

<<AInvA2Kontrolle>>=
(matRoundAInvA2 <- round(as.matrix(getAInv(pedA2)), digits = 2))
max(matRoundAInvA2-mParsedEvaledAinvA2)
@

\end{document}
