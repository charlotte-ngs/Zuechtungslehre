\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Z\"uchtungslehre - L\"osung 6}
\author{Peter von Rohr}
\maketitle

<<HelperFunctions, echo=FALSE, results=hide>>=
#' Function returning a matrix as tex output
#' @param  pmatAMatrix        Matrix to be represented in tex format
#' @param  pnOutStartLine     line index where output should start, default = 5
#' @param  pnEndIgnoreLines   number of lines to be ignored at the end of the output, default = 1
#' @return string containing tex representation of matrix
sGetTexMatrix <- function(pmatAMatrix, pnOutStartLine = 5, pnEndIgnoreLines = 1) {
  sResultTexMatrix <- capture.output(print(xtable::xtable(pmatAMatrix),
                                     include.rownames = FALSE,
                                     include.colnames = FALSE,
                                     hline.after = NULL,
                                     sanitize.text.function=identity))
  ### # do some replacements
  sResultTexMatrix <- gsub("tabular", "array",
                           sResultTexMatrix[pnOutStartLine:(length(sResultTexMatrix)-pnEndIgnoreLines)],
                           fixed = TRUE)
  return(sResultTexMatrix)
}

#' Parse and evaluate a matrix of strings
#'
#' \code{matParseEval} takes a matrix of strings and parses and evaluates the components
#'
mParseEval <- function(pmStringMat) {
  nRowResultMat <- nrow(pmStringMat)
  nColResultMat  <- ncol(pmStringMat)
  mResultMat <- matrix(0, nrow = nRowResultMat, ncol = nColResultMat)
  for (idx in 1:nRowResultMat){
    for (jdx in 1:nColResultMat) {
      mResultMat[idx,jdx] <- eval(parse(text=pmStringMat[idx,jdx]))
    }
  }
  return(mResultMat)
}

#' Parse a string into a vector of function parameters
#' @param psParseString
#' @param psFunName
#' @return vector of function parameters as strings
sParseString <- function(psParseString, psFunName) {
  vecFunParam <- unlist(strsplit(psParseString, psFunName, fixed = TRUE))
  # remove empty first character
  if (vecFunParam[1] == "") vecFunParam <- vecFunParam[2:length((vecFunParam))]
  return(vecFunParam)
}

#' Evaluate a function based on function name and vector of arguments
@


\section*{Aufgabe 1 (5)}
F\"ur Aufgabe 1 wurde folgendes Pedigree verwendet

<<pedA1>>=
library(pedigreemm)
nAnzTiere <- 6
pedA1 <- pedigree(sire = c(NA,NA,1, 1,4,4),
                dam  = c(NA,NA,2,NA,2,2), label= 1:nAnzTiere)
print(pedA1)
@

Die $\alpha_i$-Werte f\"ur die Tiere im Pedigree sind in folgender Tabelle aufgelistet.

\vspace{2ex}
\begin{center}
\begin{tabular}{|r|r|}
  \hline
  TierId & Wert in Matrix $\mathbf{D}^{-1}$ ($\alpha_i$) \\
  \hline
   1 & 1.00 \\
      \hline
   2 & 1.00 \\
      \hline
   3 & 2.00 \\
      \hline
   4 & 1.33 \\
      \hline
   5 & 2.00 \\
      \hline
   6 & 2.00 \\
   \hline
\end{tabular}
\end{center}


<<pedMM, echo=FALSE, results=hide>>=
### # Aufbau der Matrix
matAInv <- matrix("0", nrow = nAnzTiere, ncol = nAnzTiere)
alpha <- 1/Dmat(pedA1)
nTierIdx <- 1
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 2
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nTierIdx <- 3
matAInv[nTierIdx,nTierIdx] <- paste("+", alpha[nTierIdx], sep="")
nVaterIdx <- 1
nMutterIdx <- 2
matAInv[nVaterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nVaterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nMutterIdx,nTierIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nTierIdx,nMutterIdx] <- paste("-", alpha[nTierIdx]/2, sep="")
matAInv[nVaterIdx,nVaterIdx] <- paste(matAInv[nVaterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nVaterIdx,nMutterIdx] <- paste(matAInv[nVaterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nVaterIdx] <- paste(matAInv[nMutterIdx,nVaterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
matAInv[nMutterIdx,nMutterIdx] <- paste(matAInv[nMutterIdx,nMutterIdx],
                                      "+",
                                      alpha[nTierIdx]/4,
                                      sep="", collapse = "")
mParsedEvaledAinv <- mParseEval(pmStringMat = matAInv)
@

Das direkte Aufstellen der inversen Verwandtschaftsmatrix $\mathbf{A}^{-1}$ basiert auf folgenden Regeln.

\subsection*{Regeln f\"ur $\mathbf{A}^{-1}$}

\begin{itemize}
\item Initialisierung aller Elemente in $\mathbf{A}^{-1}$ mit dem Wert $0$
\item Hat Tier $i$ bekannte Eltern $m$ und $v$ dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$ (Zeile von Tier $i$ und Kolonne von Tier $i$) hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$, $(i,m)$, $(v,i)$ und $(i,v)$ abziehen
  \item ${\alpha_i \over 4}$ zu den Elementen $(m,m)$, $(m,v)$, $(v,m)$ und $(v,v)$ hinzuz\"ahlen
  \end{itemize}
\item Nur Elternteil $m$ von Tier $i$ ist bekannt, dann folgende Ver\"anderungen in $\mathbf{A}^{-1}$ vornehmen
  \begin{itemize}
  \item $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
  \item ${\alpha_i \over 2}$ von den Elementen $(m,i)$ und $(i,m)$ abziehen
  \item ${\alpha_i \over 4}$ zum Element $(m,m)$ hinzuz\"ahlen
  \end{itemize}
\item Tier $i$ hat keine bekannten Eltern, dann $\alpha_i$ zum Element $(i,i)$  hinzuz\"ahlen
\end{itemize}

\subsection*{Schritte 1 bis 3}
Schritte 1 bis 3 zur Berechnung der Anteile von $\mathbf{A}^{-1}$ f\"ur Tiere 1 bis 3 wurden in der Aufgabe vorgegeben. Nach diesen drei Schritten sieht die Matrix $\mathbf{A}^{-1}$ wie folgt aus

<<MatAInvStepThree, echo=FALSE, results=tex>>=
cat("$$\\mathbf{A}^{-1} = \\left[")
cat(paste(sGetTexMatrix(pmatAMatrix = mParsedEvaledAinv), collapse = "\n"))
cat("\\right] $$\n")
@

\subsection*{Schritt 4}
Tier 4 hat nur einen bekannten Elternteil. Aus der Tabelle der $\alpha_i$ Werte kann $\alpha_4 = 1.33$ bestimmt werden.  Somit werden folgende Betr\"age zu $\mathbf{A}^{-1}$ hinzugef\"ugt.

<<ContribStep4, echo=FALSE, results=hide>>=
nTierIdx <- 4
nVaterIdx <- pedA1@sire[nTierIdx]
@

\begin{itemize}
\item $\alpha_\Sexpr{nTierIdx} = \Sexpr{round(alpha[nTierIdx], digits=2)}$
  zum Element $(\Sexpr{nTierIdx},\Sexpr{nTierIdx})$  hinzuz\"ahlen
\item ${\alpha_\Sexpr{nTierIdx} \over 2} = \Sexpr{round(alpha[nTierIdx]/2, digits=2)}$
  von den Elementen $(\Sexpr{nVaterIdx},\Sexpr{nTierIdx})$ und
  $(\Sexpr{nTierIdx},\Sexpr{nVaterIdx})$ abziehen
\item ${\alpha_\Sexpr{nTierIdx} \over 4} = \Sexpr{round(alpha[nTierIdx]/4, digits=2)}$
  zum Element $(\Sexpr{nVaterIdx},\Sexpr{nVaterIdx})$ hinzuz\"ahlen
\end{itemize}





\section*{Aufgabe 2 ()}

\end{document}
