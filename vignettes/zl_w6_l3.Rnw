\documentclass{article}

\begin{document}
\SweaveOpts{concordance=TRUE}

\title{Z\"uchtungslehre - L\"osung 3}
\author{Peter von Rohr}
\maketitle


\section*{Aufgabe 1 (8)}
<<SimDataCharacteristics, echo=FALSE>>=
sGitDir <- ifelse(.Platform$OS.type == "windows",
                  "c:/Daten/Github",
                  "~/Data/Projects/GitHub")
bModeOnline <- FALSE
### # Define data depending on whether we are online or offline
sDataFn <- ifelse(bModeOnline,
                  "http://charlotte-ngs.github.io/LivestockBreedingAndGenomics/w5/simgenphen.csv",
                  file.path(sGitDir, "LivestockBreedingAndGenomics/gh-pages/w5/simgenphen.csv"))
dfSimGenPhenDat <- read.csv2(file = sDataFn)
@

Der in dieser Aufgabe verwendete Datensatz unter \\
\texttt{http://charlotte-ngs.github.io/LivestockBreedingAndGenomics/w5/simgenphen.csv} umfasst nur \Sexpr{nrow(dfSimGenPhenDat)} Records und wurde mit folgenden Parametern simuliert.

\vspace*{2ex}
\begin{tabular}{|c|c|}
\hline
Locus  &  additiver genotypischer Wert ($a$) \\
\hline
1      &  $10$ \\
\hline
2      &  $5$ \\
\hline
3      &  $2$ \\
\hline
\end{tabular}

\vspace*{2ex}
\noindent Als Intercept wurde ein Wert von $-10.76$ angenommen. Die Standardabweichung der Fehler betrug $2.5$.

\subsection*{Analyse des urspr\"unglichen Datensatzes}
In der Aufgabe ging es darum die multiple lineare Regression mit den simplen Regressionen f\"ur die drei Loci miteinander zu vergleichen. Bei der multiplen Regression sollten die in der Simulation verwendeten Parameter wieder als Effekte erscheinen.

<<MultLinRegOrgData>>=
lmMultRegOrg <- lm(y ~ locus1 + locus2 + locus3, data = dfSimGenPhenDat)
summary(lmMultRegOrg)
@


\subsection*{Analyse eines neuen Datensatzes}
<<SimDataNew, echo=FALSE>>=
sDatDir <- ifelse(.Platform$OS.type == "windows",
                  "C:/Daten/pvr/Google Drive/eBooks/GWH2013_Genome-Wide_Association_Studies_and_Genomic_Prediction/978-1-62703-446-3/Chapter10",
                  "~/Google Drive/eBooks/GWH2013_Genome-Wide_Association_Studies_and_Genomic_Prediction/978-1-62703-446-3/Chapter10")
### # name of the file with original data
sGenDatFn <- "Genotypes.dat"
### # number of lines to be read from orignial data file
nDataLine <- 31
### # column indices to extract
nStartCol <- 2
nEndCol <- 5
### # rowindex of header lines
nHeaderLineIdx <- 1
### # regexp with which to split columns
sColSplit <- "[ ]+"
### # constants for simulation
nInterceptTrue <- -10.76
nSubsEffLocus1 <- 2.9 #1   #
nSubsEffLocus2 <- 1.1 #0.5 #
nSubsEffLocus3 <- 0.5 #0.37 #
nMeanRes <- 0
nSdRes   <- 1
### # directory and file where results should be written to
sResultDir <- "inst/extdata/w5"
sResultFn <- "simgenphencorr.csv"
sResultFile <- file.path(sResultDir, sResultFn)

set.seed(1239)

##############################
### # functions
sGetHeaderLine <- function(psGenDataLine, pnHeaderLineIdx, psColSplit, pnStartCol, pnEndCol) {
  sResultHeaderLine <- unlist(strsplit(psGenDataLine[pnHeaderLineIdx],
                                       split = psColSplit))[pnStartCol:pnEndCol]
  return(sResultHeaderLine)
}
##############################
### # code starts here ....
### # save the current working directory
#zlwd <- getwd()
zlwd <- ifelse(.Platform$OS.type == "windows",
               "C:/Daten/GitHub/Zuechtungslehre",
               "~/Data/Projects/GitHub/Zuechtungslehre")

### # change wd to where genotype.dat is located
#setwd(sDatDir)

### # open a connection and read first 20 records with header
conDat <- file(description = file.path(sDatDir,sGenDatFn))
sGenDataLine <- readLines(con = conDat, n = nDataLine)
close(con = conDat)

sHeaderLine <- sGetHeaderLine(psGenDataLine   = sGenDataLine,
                              pnHeaderLineIdx = nHeaderLineIdx,
                              psColSplit      = sColSplit,
                              pnStartCol      = nStartCol,
                              pnEndCol        = nEndCol)

### # body of data records
matGenoDat <- matrix(data = NA, nrow = length(sGenDataLine)-1, ncol = length(sHeaderLine))
for (i in 2:length(sGenDataLine)){
  matGenoDat[(i-1),] <- as.numeric(unlist(strsplit(sGenDataLine[i],
                                                   split = sColSplit))[nStartCol:nEndCol])
}

### # generate the data
matDesignX <- matGenoDat
matDesignX[,1] <- rep(1, nrow(matGenoDat))
### # check rank of design matrix
qr(matDesignX)$rank
### # make adjustments to get full column rank
#matDesignX[2,3] <- 10
#matDesignX[17,1] <- -10
matDesignX[19,4] <- -10
#matDesignX[20,4] <- 0
#matDesignX[23,1] <- 10
#matDesignX[26,2] <- 10
qr(matDesignX)$rank

### # true beta vector
vecBetaTrue <- c(nInterceptTrue,
                 nSubsEffLocus1,
                 nSubsEffLocus2,
                 nSubsEffLocus3)
vecYTrue <- matDesignX %*% vecBetaTrue + rnorm(n = nrow(matDesignX), mean = nMeanRes, sd = nSdRes)

### # conversion to a dataframe
id <- matGenoDat[,1]
locus1 <- matDesignX[,2]/10
locus2 <- matDesignX[,3]/10
locus3 <- matDesignX[,4]/10
y <- vecYTrue
dfSimGenPhenDat <- data.frame(id,locus1, locus2, locus3, y, stringsAsFactors = FALSE)

### # fit lm
fitMultReg <- lm( y ~ locus1 + locus2 + locus3, data = dfSimGenPhenDat)
summary(fitMultReg)

### # single regressions
summary(lm(y ~ locus1, data = dfSimGenPhenDat))
summary(lm(y ~ locus2, data = dfSimGenPhenDat))
summary(lm(y ~ locus3, data = dfSimGenPhenDat))


### # re-set working directory
#setwd(zlwd)

### # write df to csv file
write.csv2(dfSimGenPhenDat, file = sResultFile, quote = FALSE, row.names = FALSE)
@

Damit der in der Aufgabe beschriebene Effekt trotzdem sichtbar gemacht werden kann, wird ein neuer Datensatz simuliert. Die Parameterwerte wurden etwas anders gew\"ahlt, so dass die Effekte eindeutig
sch\"atzbar sind.

\vspace*{2ex}
\begin{tabular}{|c|c|}
\hline
Locus  &  additiver genotypischer Wert ($a$) \\
\hline
1      &  $29$ \\
\hline
2      &  $11$ \\
\hline
3      &  $5$ \\
\hline
\end{tabular}

\vspace*{2ex}
\noindent Als Intercept wurde ein Wert von $-10.76$ angenommen. Die Standardabweichung der Fehler betrug $1$.

Der korrigierte Datensatz ist verf\"ugbar unter \\
\texttt{http://charlotte-ngs.github.io/LivestockBreedingAndGenomics/w5/simgenphencorr.csv}.

Wird die Analyse mit diesem zweiten Datensatz gemacht, und werden die Resultate der multiplen Regression mit den einzelnen einfachen Regressionen verglichen zeigt sich sehr sch\"on der gew\"unschte Effekt, dass eben nur die multiple Regression nicht aber die einfachen Regressionen die Parameter aus der Simulation als Effekte aufweisen.

Das Einlesen der Daten erfolgt wie gewohnt mit:

<<ReadCorrData, eval=FALSE>>=
dfSimGenPhenDat <- read.csv2(file = "http://charlotte-ngs.github.io/LivestockBreedingAndGenomics/w5/simgenphencorr.csv")
@

Die multiple lineare Regression

<<MultLinRegCorr>>=
fitMultLinReg <- lm(y ~ locus1 + locus2 + locus3, data = dfSimGenPhenDat)
summary(fitMultLinReg)
@




\section*{Aufgabe 2 (5)}
Analog zur in der Funktion \texttt{quadratzahl()} definieren wir die Funktion \texttt{convertCelsiusToFahrenheit()}. Als Input nimmt die Funktion die Temparatur in Grad Celsius als einziges Funktionsargument. Folgende Definition der Funktion \texttt{convertCelsiusToFahrenheit()} ist denkbar.

<<ConvertCelsiusToFahrenheitFuncDef>>=
convertCelsiusToFahrenheit <- function(pnTempC){
  nResultTempF <-32 + (9/5) * pnTempC
  return(nResultTempF)
}
@

\subsection*{Umrechnung einzelner Werte}
Einzelne Temperaturwerte k\"onnen mit einzelnen Funktionsaufrufen umgerechnet werden.

<<ConvertCelsiusToFahrenheitFuncCall>>=
convertCelsiusToFahrenheit(7)
convertCelsiusToFahrenheit(13)
convertCelsiusToFahrenheit(35)
@

\subsection*{Umrechnungstabelle}
Angenommen, wir m\"ochten die Temparaturen zwischen $-50$ und $+50$ Grad Celsius in Fahrenheit umrechnen und die Werte dann in einer Tabelle darstellen, dann k\"onnen wir das in einem Loop machen.

<<CelsiusToFahrenheitTableComp>>=
Celsius <- seq(from = -50,to = 50,by = 10)
nNrValues <- length(Celsius)
Fahrenheit <- vector(mode = "numeric", length = nNrValues)
for (i in 1:nNrValues){
  Fahrenheit[i] <- convertCelsiusToFahrenheit(Celsius[i])
}
print(Celsius)
print(Fahrenheit)
@

Die Tabelle sieht dann wie folgt aus.

<<CelsiusToFahrenheitTable, eval = FALSE, echo=FALSE>>=
#dfCelToFahr <- data.frame(Celsius, Fahrenheit)
#xtable::xtable(dfCelToFahr)
@

\end{document}
